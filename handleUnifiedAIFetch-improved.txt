  // Fonction de gestion du fetch IA unifi√©
  const handleUnifiedAIFetch = async (mode: AIFetchMode) => {
    try {
      console.log('ü§ñ [UnifiedAIFetch] D√©but fetch IA en mode:', mode);
      setIsAILoading(true);
      
      // V√©rifier qu'il y a au moins un nom
      if (!formData.name || formData.name.trim() === '') {
        throw new Error('Veuillez saisir au moins un nom de produit');
      }
      
      // R√©cup√©rer la cl√© API et le mod√®le depuis les param√®tres sauvegard√©s
      const savedSettings = localStorage.getItem('ai_settings');
      let apiKey = null;
      let model = 'claude-sonnet-4-20250514';
      
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        apiKey = settings.claudeApiKey;
        model = settings.model || model;
      }
      
      if (!apiKey) {
        alert('‚ö†Ô∏è Cl√© API Anthropic non configur√©e. Allez dans Param√®tres pour la configurer.');
        setAiProgress({ mode, step: 'error', message: 'Cl√© API non configur√©e' });
        setIsAILoading(false);
        return;
      }
      
      console.log('üîë [UnifiedAIFetch] Cl√© API r√©cup√©r√©e depuis les param√®tres');
      
      // ============================================
      // 1. REMPLISSAGE M√âTADONN√âES (si mode metas ou all)
      // ============================================
      if (mode === 'metas' || mode === 'all') {
        setAiProgress({ mode, step: 'fetching_metas', message: 'Recherche des informations...' });
        console.log('üìù [UnifiedAIFetch] √âtape 1 : Remplissage m√©tadonn√©es...');
        
        const metaResponse = await fetch('/api/ai-fill', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            productData: {
              id: product?.id,
              name: formData.name,
              brand: formData.brand,
              brand_id: (formData as any).brand_id,
              manufacturer: formData.manufacturer,
              barcode: formData.barcode,
              manufacturer_ref: formData.manufacturer_ref
            },
            apiKey,
            model
          })
        });

        if (!metaResponse.ok) {
          const errorData = await metaResponse.json();
          throw new Error(errorData.error || 'Erreur lors du remplissage des m√©tadonn√©es');
        }

        const metaData = await metaResponse.json();
        console.log('‚úÖ [UnifiedAIFetch] M√©tadonn√©es r√©cup√©r√©es:', metaData.data);
        
        // Mettre √† jour les donn√©es du formulaire avec les donn√©es IA
        if (metaData.success && metaData.data) {
          const cleanedData = { ...metaData.data };
          delete cleanedData.category; // Ne pas inclure category
          
          // Filtrer pour ne garder QUE les champs vides
          const fieldsToUpdate: Partial<ProductFormData> = {};
          let metasCount = 0;

          Object.entries(cleanedData).forEach(([key, value]) => {
            const currentValue = formData[key as keyof ProductFormData];
            if ((!currentValue || currentValue === '') && value) {
              fieldsToUpdate[key as keyof ProductFormData] = value as any;
              metasCount++;
            }
          });

          if (Object.keys(fieldsToUpdate).length > 0) {
            setFormData(prev => ({ ...prev, ...fieldsToUpdate }));
            setAiProgress(prev => ({ ...prev, metasCount }));
            setHasChanges(true);
            console.log(`‚úÖ [UnifiedAIFetch] ${metasCount} champ(s) rempli(s)`);
          } else {
            console.log('‚ÑπÔ∏è [UnifiedAIFetch] Aucun champ vide √† remplir');
          }
        }
      }

      // ============================================
      // 2. R√âCUP√âRATION IMAGES (si mode images ou all)
      // ============================================
      if (mode === 'images' || mode === 'all') {
        setAiProgress({ mode, step: 'fetching_images', message: 'R√©cup√©ration des images...' });
        console.log('üì∏ [UnifiedAIFetch] √âtape 2 : R√©cup√©ration images...');

        const imagesResponse = await fetch('/api/ai-fill', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            productData: {
              id: product?.id,
              name: formData.name,
              brand: formData.brand,
              manufacturer: formData.manufacturer,
              barcode: formData.barcode
            },
            images_only: true,
            apiKey,
            model
          })
        });

        if (!imagesResponse.ok) {
          const errorData = await imagesResponse.json();
          throw new Error(errorData.error || 'Erreur lors de la r√©cup√©ration des images');
        }

        const imagesData = await imagesResponse.json();
        console.log('‚úÖ [UnifiedAIFetch] Images r√©cup√©r√©es:', imagesData.supabaseImages?.length || 0);
        
        // Classifier les images si n√©cessaire
        if (imagesData.supabaseImages && imagesData.supabaseImages.length > 0 && product?.id) {
          // Recharger les images depuis la BDD
          const { ProductImageService } = await import('@/lib/productImageService');
          let allImages = await ProductImageService.getByProductId(product.id);
          
          if (allImages.length > 0) {
            console.log('üé® [UnifiedAIFetch] Classification de', allImages.length, 'images...');
            
            const classifyResponse = await fetch('/api/classify-images', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                imageUrls: allImages.map(img => img.url),
                productName: formData.name,
                apiKey,
                model,
                filterType: 'all'
              })
            });

            if (classifyResponse.ok) {
              const classifyData = await classifyResponse.json();
              console.log('‚úÖ [UnifiedAIFetch] Classification termin√©e');

              // Supprimer les images "unwanted"
              for (const analysis of classifyData.analyses || []) {
                if (analysis.type === 'unwanted' && allImages[analysis.index]) {
                  await ProductImageService.delete(allImages[analysis.index].id);
                  console.log(`üóëÔ∏è [UnifiedAIFetch] Image unwanted supprim√©e: ${analysis.index}`);
                }
              }
            }
          }
          
          // Recompter apr√®s classification
          allImages = await ProductImageService.getByProductId(product.id);
          setAiProgress(prev => ({ ...prev, imagesCount: allImages.length }));
          
          // Configurer l'image principale si n√©cessaire
          const hasFeatured = allImages.some(img => img.is_featured);
          if (!hasFeatured && allImages.length > 0) {
            const firstProductImage = allImages.find(img => img.image_type === 'product');
            const imageToFeature = firstProductImage || allImages[0];
            await ProductImageService.update(imageToFeature.id, { is_featured: true });
            
            if (onThumbnailChange) {
              onThumbnailChange();
            }
          }
          
          console.log(`‚úÖ [UnifiedAIFetch] ${allImages.length} image(s) trait√©e(s)`);
        }
      }

      setAiProgress({ mode, step: 'complete', message: 'Termin√© !' });
      console.log('‚úÖ [UnifiedAIFetch] Fetch IA termin√© avec succ√®s');
      
    } catch (error: any) {
      console.error('‚ùå [UnifiedAIFetch] Erreur fetch IA:', error);
      setAiProgress({ mode, step: 'error', message: error.message || 'Erreur lors du fetch IA' });
      alert(`‚ùå Erreur lors du fetch IA: ${error.message}`);
    } finally {
      setIsAILoading(false);
      setTimeout(() => {
        setAiProgress({ mode: 'all', step: 'idle', message: '' });
      }, 2000);
    }
  };

