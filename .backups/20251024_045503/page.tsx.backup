'use client';

import { useState, useEffect, useCallback } from 'react';
import { Package, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Product } from '@/lib/supabase';
import { ProductService } from '@/lib/services';
import CompactProductList from '@/components/inventory/CompactProductList';
import ProductInspector from '@/components/inventory/ProductInspector';


export default function Home() {
  // √âtats pour les donn√©es r√©elles de Supabase
  const [products, setProducts] = useState<Product[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [showInspector, setShowInspector] = useState(false);

  // Fonction pour charger les produits depuis Supabase
  const loadProducts = useCallback(async () => {
    try {
      setIsLoading(true);
      console.log('üîÑ Chargement des produits depuis Supabase...');
      
      const productsData = await ProductService.getAll();
      console.log('‚úÖ Produits charg√©s depuis Supabase:', productsData.length);
      
      if (productsData.length > 0) {
        // Nettoyer les donn√©es pour √©viter les erreurs de rendu
        const cleanedProducts = productsData.map(product => ({
          ...product,
          barcode: product.barcode || '',
          notes: product.notes || '',
          image_url: product.image_url || '',
          internal_ref: product.internal_ref || '',
          metadata: product.metadata || {},
          warranty_period: product.warranty_period || '',
          min_stock_required: product.min_stock_required || false,
          min_stock_quantity: product.min_stock_quantity || 0
        }));
        
        setProducts(cleanedProducts);
        console.log('üìä Donn√©es Supabase charg√©es et nettoy√©es avec succ√®s');
      } else {
        console.log('üì≠ Aucun produit trouv√© dans Supabase');
        setProducts([]);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Erreur lors du chargement des produits:', error);
      setProducts([]);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Charger les produits au montage du composant
  useEffect(() => {
    loadProducts();
  }, [loadProducts]);

  // Fonction pour g√©rer la s√©lection de produit
  const handleSelectProduct = useCallback((product: Product) => {
    setSelectedProduct(product);
    setShowInspector(true);
  }, []);

  // Fonction pour fermer l'inspecteur
  const handleCloseInspector = useCallback(() => {
    setShowInspector(false);
    setSelectedProduct(null);
  }, []);

  // Fonction pour sauvegarder les modifications d'un produit
  const handleUpdateProduct = useCallback(async (data: any) => {
    if (!selectedProduct) return;
    
    try {
      console.log('üíæ [page.tsx] D√©but handleUpdateProduct');
      
      // Mettre √† jour le produit dans Supabase
      const updatedProduct = await ProductService.update(selectedProduct.id, data);
      
      if (updatedProduct) {
        console.log('‚úÖ Produit mis √† jour avec succ√®s');
        
        // Recharger la liste des produits
        await loadProducts();
        
        // NE PAS fermer l'inspecteur pour permettre d'autres modifications
        // L'utilisateur peut fermer manuellement avec le bouton X
      } else {
        console.error('‚ùå Erreur lors de la mise √† jour du produit');
      }
    } catch (error) {
      console.error('‚ùå [page.tsx] Erreur lors de la sauvegarde:', error);
    }
  }, [selectedProduct, loadProducts, handleCloseInspector]);

  // Fonction pour supprimer un produit
  const handleDeleteProduct = useCallback(async (id: string) => {
    try {
      console.log('üóëÔ∏è Suppression du produit:', id);
      
      const success = await ProductService.delete(id);
      
      if (success) {
        console.log('‚úÖ Produit supprim√© avec succ√®s');
        
        // Recharger la liste des produits
        await loadProducts();
        
        // Fermer l'inspecteur
        handleCloseInspector();
      } else {
        console.error('‚ùå Erreur lors de la suppression du produit');
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de la suppression:', error);
    }
  }, []);

  // Fonction de remplissage IA automatique complet (m√©tadonn√©es + photos)
  const handleAIFill = useCallback(async (product: Product, onProgress?: (step: 'idle' | 'starting' | 'fetching_metadata' | 'scraping_images' | 'classifying_images' | 'complete' | 'error') => void): Promise<{ images: number; metas: number }> => {
    console.log('üé® [AI Auto-Fill] D√©but remplissage automatique:', product.name);
    
    try {
      // R√©cup√©rer les param√®tres AI depuis localStorage
      const savedSettings = localStorage.getItem('ai_settings');
      let apiKey = null;
      let model = 'claude-sonnet-4-20250514';
      
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        apiKey = settings.claudeApiKey;
        model = settings.model || model;
      }

      if (!apiKey) {
        alert('‚ö†Ô∏è Cl√© API Anthropic non configur√©e. Allez dans Param√®tres.');
        throw new Error('API key not configured');
      }

      // 1. Remplissage des m√©tadonn√©es
      if (onProgress) onProgress('fetching_metadata');
      console.log('üìù [AI Auto-Fill] √âtape 1/3 : R√©cup√©ration m√©tadonn√©es...');
      console.log('üîç [AI Auto-Fill] Donn√©es produit:', {
        id: product.id,
        name: product.name,
        manufacturer_ref: product.manufacturer_ref,
        brand: product.brand
      });
      
      const metaResponse = await fetch('/api/ai-fill', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          product,
          apiKey,
          model
        })
      });

      if (!metaResponse.ok) {
        const errorText = await metaResponse.text();
        console.error('‚ùå [AI Auto-Fill] Erreur API:', errorText);
        throw new Error(`Erreur API ${metaResponse.status}: ${errorText}`);
      }

      const metaData = await metaResponse.json();
      console.log('‚úÖ [AI Auto-Fill] M√©tadonn√©es r√©cup√©r√©es:', metaData);

      // V√©rifier que l'IA a bien retourn√© des donn√©es valides
      if (!metaData.success || !metaData.data) {
        console.warn('‚ö†Ô∏è [AI Auto-Fill] R√©ponse IA invalide:', metaData);
        throw new Error('R√©ponse IA invalide');
      }

      // V√©rifier que le nom du produit n'est pas un message d'erreur
      if (metaData.data.name && (
        metaData.data.name.toLowerCase().includes('absence') ||
        metaData.data.name.toLowerCase().includes('erreur') ||
        metaData.data.name.toLowerCase().includes('impossible')
      )) {
        console.warn('‚ö†Ô∏è [AI Auto-Fill] Message d\'erreur d√©tect√© dans le nom:', metaData.data.name);
        delete metaData.data.name; // Ne pas √©craser le nom avec un message d'erreur
      }

      // 2. Scraping et upload des images
      if (onProgress) onProgress('scraping_images');
      console.log('üì∏ [AI Auto-Fill] √âtape 2/3 : R√©cup√©ration des images...');
      const imagesResponse = await fetch('/api/ai-fill', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          product,
          apiKey,
          model,
          images_only: true,
          filterType: 'all'
        })
      });

      if (!imagesResponse.ok) {
        throw new Error('Erreur lors de la r√©cup√©ration des images');
      }

      const imagesData = await imagesResponse.json();
      const imageUrls = imagesData.supabaseImages || [];
      console.log('‚úÖ [AI Auto-Fill] Images scrap√©es:', imageUrls.length);
      console.log('üñºÔ∏è [AI Auto-Fill] URLs images:', imageUrls);

      // 2.5. T√©l√©chargement des images et enregistrement en BDD
      if (imageUrls.length > 0) {
        console.log('‚¨áÔ∏è [AI Auto-Fill] T√©l√©chargement et enregistrement en BDD...');
        const downloadResponse = await fetch('/api/download-images', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            imageUrls: imageUrls,
            productId: product.id
          })
        });

        if (!downloadResponse.ok) {
          console.error('‚ùå [AI Auto-Fill] Erreur t√©l√©chargement images');
        } else {
          const downloadData = await downloadResponse.json();
          const downloadedCount = downloadData.results?.filter((r: any) => r.success).length || 0;
          console.log('‚úÖ [AI Auto-Fill] Images t√©l√©charg√©es et enregistr√©es:', downloadedCount);
        }
      }

      // 2.6. Classification des images par l'IA
      if (onProgress) onProgress('classifying_images');

      // 2.7. Compter le nombre TOTAL d'images du produit (apr√®s t√©l√©chargement)
      let totalImagesCount = 0;
      try {
        const { ProductImageService } = await import('@/lib/productImageService');
        const allImages = await ProductImageService.getByProductId(product.id);
        totalImagesCount = allImages.length;
        console.log('üìä [AI Auto-Fill] Total images du produit:', totalImagesCount);
      } catch (error) {
        console.error('‚ùå [AI Auto-Fill] Erreur comptage images:', error);
      }

      // 3. Mise √† jour du produit avec les m√©tadonn√©es
      console.log('üíæ [AI Auto-Fill] √âtape 3/3 : Sauvegarde...');
      
      // Nettoyer les donn√©es avant mise √† jour (retirer les champs invalides)
      const cleanedData = { ...metaData.data };
      delete cleanedData.category; // Supprimer "category" (c'est "category_id" qu'il faut)
      console.log('üßπ [AI Auto-Fill] Donn√©es nettoy√©es:', Object.keys(cleanedData));
      
      // Compter le nombre de m√©tadonn√©es ajout√©es
      const metasCount = Object.keys(cleanedData).filter(key => {
        const value = cleanedData[key as keyof typeof cleanedData];
        return value !== null && value !== '' && value !== undefined;
      }).length;
      console.log('üìä [AI Auto-Fill] Nombre de m√©tadonn√©es ajout√©es:', metasCount);
      
      const updatedProduct = await ProductService.update(product.id, cleanedData);
      console.log('‚úÖ [AI Auto-Fill] Produit mis √† jour avec succ√®s');

      // Mettre √† jour localement le produit dans la liste sans tout recharger
      if (updatedProduct) {
        setProducts(prevProducts => 
          prevProducts.map(p => 
            p.id === product.id ? { ...p, ...updatedProduct } : p
          )
        );
      }
      
      console.log('üéâ [AI Auto-Fill] Remplissage automatique termin√© !');
      console.log(`üìà [AI Auto-Fill] R√©sum√©: ${totalImagesCount} images (total), ${metasCount} metas`);
      
      // Retourner le vrai r√©sum√© avec le TOTAL d'images
      return { images: totalImagesCount, metas: metasCount };
    } catch (error) {
      console.error('‚ùå [AI Auto-Fill] Erreur:', error);
      throw error;
    }
  }, []);

  // Filtrer les produits avec recherche am√©lior√©e
  const filteredProducts = products.filter(product => {
    if (!searchQuery.trim()) return true;
    const query = searchQuery.toLowerCase();
    
      // Recherche dans tous les champs pertinents
    const searchableFields = [
      product.name,
      product.barcode,
      product.manufacturer,
      product.internal_ref,
      product.manufacturer_ref,
      product.brand,
      product.short_description,
      (product as any).categories?.name,
      // Recherche dans les m√©tadonn√©es
      ...Object.values(product.metadata || {}).map(v => String(v))
    ].filter(Boolean);
    
    return searchableFields.some(field => 
      String(field).toLowerCase().includes(query)
    );
  });

  return (
    <>
      <main className="min-h-screen">
        <div>
          {isLoading ? (
            <div className="flex flex-col items-center justify-center py-20">
              <Loader2 className="h-12 w-12 animate-spin text-primary mb-4" />
              <p className="text-muted-foreground">Chargement des produits...</p>
            </div>
          ) : filteredProducts.length === 0 ? (
            <div className="text-center py-20">
              <Package className="h-20 w-20 text-muted mx-auto mb-4" />
              <h2 className="text-2xl font-bold text-foreground mb-2">
                {searchQuery ? 'Aucun r√©sultat' : 'Aucun produit'}
              </h2>
              <p className="text-muted-foreground mb-6">
                {searchQuery
                  ? 'Essayez une autre recherche'
                  : 'Commencez par ajouter un produit'}
              </p>
            </div>
          ) : (
            <>
              {/* Liste de produits avec filtres et colonnes */}
              <CompactProductList
                products={filteredProducts}
                onProductSelect={handleSelectProduct}
                onStockEdit={(product) => {
                  console.log('Modification stock:', product.name);
                  // TODO: Ouvrir le wizard de stock
                }}
                onAIFill={handleAIFill}
                searchQuery={searchQuery}
                onSearchChange={setSearchQuery}
              />
            </>
          )}
        </div>
      </main>

      {/* Inspecteur de produit */}
      {showInspector && selectedProduct && (
        <ProductInspector
          product={selectedProduct}
          onClose={handleCloseInspector}
          onSubmit={handleUpdateProduct}
          onDelete={handleDeleteProduct}
        />
      )}
    </>
  );
}
