import { supabase, Product, Category } from './supabase';

// Services pour g√©rer les produits
export const ProductService = {
  // R√©cup√©rer tous les produits
  async getAll(): Promise<Product[]> {
    console.log('üì¶ ProductService.getAll() - D√©but requ√™te...');
    const { data, error } = await supabase
      .from('products')
      .select('*, categories(name)')
      .order('created_at', { ascending: false });

    if (error) {
      console.warn('‚ö†Ô∏è Erreur lors du chargement des produits:', error);
      return [];
    }

    console.log('‚úÖ ProductService.getAll() - R√©f√©rences r√©cup√©r√©es:', data?.length || 0);
    console.log('Donn√©es:', data);
    return data || [];
  },

  // R√©cup√©rer un produit par code-barres
  async getByBarcode(barcode: string): Promise<Product | null> {
    const { data, error } = await supabase
      .from('products')
      .select('*, categories(name)')
      .eq('barcode', barcode)
      .single();

    if (error) {
      console.warn('‚ö†Ô∏è Erreur lors du chargement du produit:', error);
      return null;
    }

    return data;
  },

  // Cr√©er un nouveau produit
  async create(product: Omit<Product, 'id' | 'created_at' | 'updated_at'>): Promise<Product | null> {
    console.log('‚ûï ProductService.create() - Cr√©ation r√©f√©rence:', product);
    const { data, error } = await supabase
      .from('products')
      .insert([product])
      .select()
      .single();

    if (error) {
      console.warn('‚ö†Ô∏è Erreur lors de la cr√©ation du produit:', error);
      return null;
    }

    console.log('‚úÖ ProductService.create() - R√©f√©rence cr√©√©e:', data);

    // Ajouter √† l'historique
    await this.addHistory(data.id, 'added', null, `Produit ajout√©: ${product.name}`);

    return data;
  },

  // Mettre √† jour un produit
  async update(id: string, updates: Partial<Product>): Promise<Product | null> {
    console.log('üìù [ProductService.update] Donn√©es re√ßues:', updates);
    
    const { data, error } = await supabase
      .from('products')
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq('id', id)
      .select()
      .single();

    if (error) {
      console.error('‚ùå [ProductService.update] Erreur Supabase:');
      console.error('‚ùå Message:', error.message);
      console.error('‚ùå Code:', error.code);
      console.error('‚ùå D√©tails:', error.details);
      console.error('‚ùå Hint:', error.hint);
      console.error('‚ùå Donn√©es envoy√©es:', updates);
      return null;
    }

    await this.addHistory(id, 'updated', null, 'Produit mis √† jour');

    console.log('‚úÖ [ProductService.update] Produit mis √† jour:', data);
    return data;
  },

  // Mettre √† jour la quantit√©
  async updateQuantity(id: string, quantityChange: number): Promise<boolean> {
    const { data: product, error: fetchError } = await supabase
      .from('products')
      .select('quantity')
      .eq('id', id)
      .single();

    if (fetchError || !product) {
      console.warn('‚ö†Ô∏è Erreur lors du chargement du produit pour mise √† jour quantit√©:', fetchError);
      return false;
    }

    const newQuantity = product.quantity + quantityChange;

    const { error } = await supabase
      .from('products')
      .update({ 
        quantity: newQuantity,
        updated_at: new Date().toISOString() 
      })
      .eq('id', id);

    if (error) {
      console.warn('‚ö†Ô∏è Erreur lors de la mise √† jour de la quantit√©:', error);
      return false;
    }

    await this.addHistory(
      id, 
      'stock_change', 
      quantityChange, 
      `Changement de stock: ${quantityChange > 0 ? '+' : ''}${quantityChange}`
    );

    return true;
  },

  // Supprimer un produit
  async delete(id: string): Promise<boolean> {
    await this.addHistory(id, 'deleted', null, 'Produit supprim√©');

    const { error } = await supabase
      .from('products')
      .delete()
      .eq('id', id);

    if (error) {
      console.warn('‚ö†Ô∏è Erreur lors de la suppression du produit:', error);
      return false;
    }

    return true;
  },

  // Rechercher des produits
  async search(query: string): Promise<Product[]> {
    const { data, error } = await supabase
      .from('products')
      .select('*, categories(name)')
      .or(`name.ilike.%${query}%,barcode.ilike.%${query}%,internal_ref.ilike.%${query}%,manufacturer.ilike.%${query}%`)
      .order('created_at', { ascending: false });

    if (error) {
      console.warn('‚ö†Ô∏è Erreur lors de la recherche de produits:', error);
      return [];
    }

    return data || [];
  },

  // Ajouter √† l'historique
  async addHistory(
    productId: string, 
    action: 'added' | 'updated' | 'deleted' | 'stock_change',
    quantityChange: number | null = null,
    notes: string | null = null
  ): Promise<void> {
    await supabase
      .from('product_history')
      .insert([{
        product_id: productId,
        action,
        quantity_change: quantityChange,
        notes,
      }]);
  },
};

// Services pour g√©rer les cat√©gories
export const CategoryService = {
  // R√©cup√©rer toutes les cat√©gories
  async getAll(): Promise<Category[]> {
    const { data, error } = await supabase
      .from('categories')
      .select('*')
      .order('name', { ascending: true });

    if (error) {
      console.warn('‚ö†Ô∏è Erreur lors du chargement des cat√©gories:', error);
      return [];
    }

    return data || [];
  },

  // Cr√©er une nouvelle cat√©gorie
  async create(name: string, description: string | null = null): Promise<Category | null> {
    const { data, error } = await supabase
      .from('categories')
      .insert([{ name, description }])
      .select()
      .single();

    if (error) {
      console.warn('‚ö†Ô∏è Erreur lors de la cr√©ation de cat√©gorie:', error);
      return null;
    }

    return data;
  },
};


