---
description: "Conventions React - composants fonctionnels, hooks, état, performance"
globs: "*.tsx,*.jsx"
alwaysApply: true
---

# Conventions React

## Composants Fonctionnels UNIQUEMENT

### Toujours utiliser composants fonctionnels avec hooks

<example>
// ✅ BON : Composant fonctionnel avec TypeScript
interface ProductCardProps {
  product: Product;
  onEdit: (product: Product) => void;
  onDelete?: (id: string) => void;
  className?: string;
}

export default function ProductCard({ 
  product, 
  onEdit, 
  onDelete,
  className 
}: ProductCardProps) {
  // 1. États locaux
  const [isHovered, setIsHovered] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  
  // 2. Effets
  useEffect(() => {
    // Logique d'effet
    return () => {
      // Cleanup
    };
  }, [product.id]);
  
  // 3. Callbacks memoizés
  const handleClick = useCallback(() => {
    onEdit(product);
  }, [product, onEdit]);
  
  // 4. Valeurs calculées memoizées
  const displayStatus = useMemo(() => {
    if (product.quantity === 0) return 'Rupture';
    if (product.quantity < 5) return 'Stock faible';
    return 'En stock';
  }, [product.quantity]);
  
  // 5. Render
  return (
    <div className={cn('card', className)}>
      {/* Contenu */}
    </div>
  );
}
</example>

<example type="invalid">
// ❌ MAUVAIS : Composant classe (éviter)
class ProductCard extends React.Component {
  render() {
    return <div>...</div>;
  }
}
</example>

## Ordre des Hooks

### Respecter l'ordre : États → Effets → Callbacks → Render

<example>
export default function MyComponent() {
  // 1. États
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  
  // 2. Effets
  useEffect(() => {
    loadData();
  }, []);
  
  // 3. Callbacks
  const handleClick = useCallback(() => {
    /* ... */
  }, []);
  
  // 4. Render
  return <div>...</div>;
}
</example>

## Hooks Personnalisés

<example>
// ✅ BON : Hook personnalisé bien typé
function useProducts() {
  const [products, setProducts] = useState<Product[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    loadProducts();
  }, []);

  const loadProducts = async () => {
    try {
      setIsLoading(true);
      const data = await ProductService.getAll();
      setProducts(data);
    } catch (err) {
      setError(err as Error);
    } finally {
      setIsLoading(false);
    }
  };

  return { products, isLoading, error, reload: loadProducts };
}

// Utilisation
const { products, isLoading, error } = useProducts();
</example>

## Gestion d'État

### Mise à jour immutable OBLIGATOIRE

<example>
// ✅ BON : État structuré et typé
interface ProductsState {
  items: Product[];
  selected: Product | null;
  isLoading: boolean;
  error: string | null;
}

const [state, setState] = useState<ProductsState>({
  items: [],
  selected: null,
  isLoading: true,
  error: null
});

// Mise à jour immutable
setState(prev => ({
  ...prev,
  items: [...prev.items, newProduct]
}));
</example>

<example type="invalid">
// ❌ MAUVAIS : Mutations directes
state.items.push(newProduct);  // Mutation !
setState(state);                // Ne déclenche pas de re-render
</example>

## Performance

### Optimisation avec memoization

<example>
// ✅ Memoization des calculs coûteux
const expensiveValue = useMemo(() => {
  return products.reduce((sum, p) => sum + p.quantity, 0);
}, [products]);

// ✅ Callbacks memoizés
const handleEdit = useCallback((product: Product) => {
  setSelectedProduct(product);
}, []);

// ✅ Debounce pour les recherches
const debouncedSearch = useMemo(
  () => debounce((query: string) => {
    performSearch(query);
  }, 300),
  []
);
</example>

## Props et Children

<example>
// ✅ Typage des props avec children
interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
}

function Modal({ isOpen, onClose, title, children }: ModalProps) {
  if (!isOpen) return null;
  
  return (
    <div className="modal">
      <h2>{title}</h2>
      {children}
    </div>
  );
}
</example>

## Composants Shadcn/ui

### Toujours utiliser les composants Shadcn existants

<example>
// ✅ BON : Utiliser composants Shadcn
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Dialog } from '@/components/ui/dialog';

<Button variant="primary" size="lg">
  Action
</Button>
</example>

<example type="invalid">
// ❌ MAUVAIS : Créer ses propres boutons
<button className="custom-button">
  Action
</button>
</example>
